import java.util.*;

// this will contain all the maze solving algorithms (incomplete)
public class MazeSolver {

	// initialize our grid, counter and 2 end points 
    private Tile[][] maze;
    private Counter counter;
    private Tile start;
    private Tile end;

    public MazeSolver(Tile[][] maze) {
        this.maze = maze;
        this.counter = new Counter(0);
        locateStartAndEnd();
    }

    
    private void locateStartAndEnd() {
        for (Tile[] row : maze) {
            for (Tile tile : row) {
            	
                if (tile.isStart()) 
                	start = tile;
                
                if (tile.isEnd())
                	end = tile;
            }
        }
        if (start == null || end == null) {
            throw new IllegalStateException("Start or End tile not found.");
        }
    }
    
    
    public boolean DFS() {
    	
    	// a stack frontier with initial starting tile
        Stack<Tile> stack = new Stack<>();
        stack.push(start);
        start.setVisited(true);

        // loop until we finish the stack  
        while (!stack.isEmpty()) {
        	
        	// pop the first tile 
            Tile current = stack.pop();

            // check if it is the end tile, if not then apply special effects before we continue 
            if (current.isEnd()) {
                System.out.println("Reached the end! Final counter: " + counter.value);
                return true;
            }

            // applying special effect
            Tile next = current.applySpecialEffect(counter, maze);

            // if we teleport into a different place, we need to mark it as visited and mark the teleportation tile as the parent tile 
            if (next != current) {
                next.setVisited(true);
                next.setParent(current);
                stack.push(next);
                continue;
            }

            // add all neighbors into the stack
            for (Tile neighbor : current.getValidNeighbors(maze)) {
                neighbor.setVisited(true);
                neighbor.setParent(current);
                stack.push(neighbor);
            }
        }

        System.out.println("No path found.");
        return false;
    }
    
    
    public List<Tile> reconstructPath(Tile end) {
        List<Tile> path = new ArrayList<>();

        Tile current = end;
        while (current != null) {
            path.add(current);
            current = current.getParent();
        }

        // The path is from end to start, so we reverse it
        Collections.reverse(path);
        return path;
    }


    
    
    
}
